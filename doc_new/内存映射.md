# 内存分配

## 需求

### #define SYS_munmap 215
* 功能：将文件或设备取消映射到内存中；
* 输入：映射的指定地址及区间；
* 返回值：成功返回0，失败返回-1;
```
void *start, size_t len
int ret = syscall(SYS_munmap, start, len);
```
### #define SYS_mmap 222
* 功能：将文件或设备映射到内存中；
* 输入：
    - start: 映射起始位置，
    - len: 长度，
    - prot: 映射的内存保护方式，可取：PROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONE
    - flags: 映射是否与其他进程共享的标志，
    - fd: 文件句柄，
    - off: 文件偏移量；
* 返回值：成功返回已映射区域的指针，失败返回-1;
```
void *start, size_t len, int prot, int flags, int fd, off_t off
long ret = syscall(SYS_mmap, start, len, prot, flags, fd, off);
```

### 也就是将文件fd映射到内存中

## 实现方式

* 在proc中加入VMA表指针
* 实现mmap munmap 以及 writebacck
* 在usertrap里进行mmap_handler
* 更新fork 和 exit

* 我们在实现此部分时重新移植了xv6的mmap模块
* 并且由于先前放弃了ip 改用 ep 此处进行了一些冲突的处理

## 调试

* 目前调试过程中主要问题有：
* writeback函数将数据写回映射源时，ewrite认为src不属于可读内存，无法rewrite
* munmap陷入死循环（可能也和src不可访问有关）
* user可能导致的bug